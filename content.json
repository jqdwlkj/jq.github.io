{"meta":{"title":"XiaoQi's Blog","subtitle":"Serious life.","description":"专注于Web前端,分享生活,分享知识","author":"XiaoQi","url":"https://www.iamys.club","root":"/"},"pages":[{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T13:00:58.441Z","comments":true,"path":"contact/index.html","permalink":"https://www.iamys.club/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:59:50.241Z","comments":true,"path":"categories/index.html","permalink":"https://www.iamys.club/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:58:58.164Z","comments":true,"path":"about/index.html","permalink":"https://www.iamys.club/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-04-08T13:02:15.797Z","comments":true,"path":"friends/index.html","permalink":"https://www.iamys.club/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-04-08T12:54:45.821Z","comments":true,"path":"tags/index.html","permalink":"https://www.iamys.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git常用命令","slug":"git","date":"2020-06-24T16:00:00.000Z","updated":"2020-07-24T13:01:38.108Z","comments":true,"path":"2020/06/25/git/","link":"","permalink":"https://www.iamys.club/2020/06/25/git/","excerpt":"","text":"git常用命令git是一个版本管理系统VCS，它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点将更新记录恢复回来。 git工作流程工作目录 被git管理的项目目录 暂存区 临时存放被修改文件 git仓库 用于存放提取记录 git使用前的配置配置提交人姓名 git config –global user.name 提交人姓名 配置提交人邮箱 git config –global user.email 提交人邮箱 查看配置 git config –list 提交步骤初始化git仓库 git init 查看文件信息 git status 添加到暂存区 git add 文件列表 向仓库提交 git commit -m 提交信息 查看提交记录 git log 查看提交记录 撤销暂存区覆盖工作目录 git checkout 文件 文件从暂存区中删除 git rm –cached 文件 git仓库中恢复覆盖暂存区和工作目录 git rest –hard commitID 分支分支细分 主分支 master 第一次向git仓库提交记录时自动产生的一个分支 开发分支 develop 作为开发的分支，基于master分支创建的 功能分支 feature 作为具体功能的分支，基于开发分支创建 分支命令 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 合并分支 git merge 来源分支 删除分支 git branch -d 分支名称 （-D 强制删除） 暂时保存更改存储临时改动 git stash 恢复改动 git stash pop github注册多人协作开发流程A在自己的计算机中创建本地仓库A在github中创建远程仓库A将本地仓库推送到远程仓库B克隆远程仓库到本地进行开发B将本地仓库中开发的内容推送到远程仓库A将远程仓库中的最新内容拉去到本地 创建仓库 填写仓库基本信息 将本地仓库推送到远程仓库 推送 git push 远程仓库地址 分支名称 添加地址别名 git remote add 远程仓库别名 远程仓库 别名推送 git push 远程仓库别名 分支名称 简便推送 git -u 远程仓库别名 分支名称 git push 拉取操作 克隆仓库 git clone 仓库地址 拉取最新信息 git pull 远程地址 分支名称 解决冲突在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。 跨团队协作程序员 C fork仓库程序员 C 将仓库克隆在本地进行修改程序员 C 将仓库推送到远程程序员 C 发起pull reqest原仓库作者审核原仓库作者合并代码 ssh免登录生成秘钥：ssh-keygen秘钥存储目录：C:\\Users\\用户.ssh公钥名称：id_rsa.pub私钥名称：id_rsa git忽略清单将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。git忽略清单文件名称：.gitignore将工作目录中的文件全部添加到暂存区：git add . XMind: ZEN - Trial Version","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.iamys.club/tags/git/"}]},{"title":"初识爬虫","slug":"大数据2020","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-24T13:04:47.067Z","comments":true,"path":"2020/06/20/大数据2020/","link":"","permalink":"https://www.iamys.club/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE2020/","excerpt":"","text":"项目分析利用大数据实验环境完成一个真实的项目。以房天下西安站二手房源数据为分析对象，使用用Numpy + Pandas库对数据进行探索性分析。首先通过Pandas对象将其从Excel电子表格中导入到数据框中。然后，对房源数据进行清洗。最后，对各关键字段字段进行相应的可视化处理。 首先导入要使用的科学计算包numpy,pandas,可视化matplotlib,seaborn,以及机器学习包sklearn。 import pandas as pd import numpy as np import seaborn as sns import matplotlib as mpl import matplotlib.pyplot as plt from IPython.display import display plt.style.use(&quot;fivethirtyeight&quot;) sns.set_style({&#39;font.sans-serif&#39;:[&#39;simhei&#39;,&#39;Arial&#39;]}) %matplotlib inline # 检查Python版本 from sys import version_info if version_info.major != 3: raise Exception(&#39;请使用Python 3 来完成此项目&#39;) 复制代码然后导入数据，并进行初步的观察，这些观察包括了解数据特征的缺失值，异常值，以及大概的描述性统计。 # 导入链家二手房数据 lianjia_df = pd.read_csv(&#39;lianjia.csv&#39;) display(lianjia_df.head(n=2)) 复制代码 初步观察到一共有11个特征变量，Price 在这里是我们的目标变量，然后我们继续深入观察一下。 # 检查缺失值情况 lianjia_df.info() 发现了数据集一共有23677条数据，其中Elevator特征有明显的缺失值。 lianjia_df.describe() 上面结果给出了特征值是数值的一些统计值，包括平均数，标准差，中位数，最小值，最大值，25%分位数，75%分位数。这些统计结果简单直接，对于初始了解一个特征好坏非常有用，比如我们观察到 Size 特征 的最大值为1019平米，最小值为2平米，那么我们就要思考这个在实际中是不是存在的，如果不存在没有意义，那么这个数据就是一个异常值，会严重影响模型的性能。 当然，这只是初步观察，后续我们会用数据可视化来清晰的展示，并证实我们的猜测。 # 添加新特征房屋均价 df = lianjia_df.copy() df[&#39;PerPrice&#39;] = lianjia_df[&#39;Price&#39;]/lianjia_df[&#39;Size&#39;] # 重新摆放列位置 columns = [&#39;Region&#39;, &#39;District&#39;, &#39;Garden&#39;, &#39;Layout&#39;, &#39;Floor&#39;, &#39;Year&#39;, &#39;Size&#39;, &#39;Elevator&#39;, &#39;Direction&#39;, &#39;Renovation&#39;, &#39;PerPrice&#39;, &#39;Price&#39;] df = pd.DataFrame(df, columns = columns) # 重新审视数据集 display(df.head(n=2))我们发现Id特征其实没有什么实际意义，所以将其移除。由于房屋单价分析起来比较方便，简单的使用总价/面积就可得到，所以增加一个新的特征 PerPrice（只用于分析，不是预测特征）。另外，特征的顺序也被调整了一下，看起来比较舒服。 数据可视化分析Region特征分析对于区域特征，我们可以分析不同区域房价和数量的对比。 # 对二手房区域分组对比二手房数量和每平米房价 df_house_count = df.groupby(&#39;Region&#39;)[&#39;Price&#39;].count().sort_values(ascending=False).to_frame().reset_index() df_house_mean = df.groupby(&#39;Region&#39;)[&#39;PerPrice&#39;].mean().sort_values(ascending=False).to_frame().reset_index() f, [ax1,ax2,ax3] = plt.subplots(3,1,figsize=(20,15)) sns.barplot(x=&#39;Region&#39;, y=&#39;PerPrice&#39;, palette=&quot;Blues_d&quot;, data=df_house_mean, ax=ax1) ax1.set_title(&#39;北京各大区二手房每平米单价对比&#39;,fontsize=15) ax1.set_xlabel(&#39;区域&#39;) ax1.set_ylabel(&#39;每平米单价&#39;) sns.barplot(x=&#39;Region&#39;, y=&#39;Price&#39;, palette=&quot;Greens_d&quot;, data=df_house_count, ax=ax2) ax2.set_title(&#39;北京各大区二手房数量对比&#39;,fontsize=15) ax2.set_xlabel(&#39;区域&#39;) ax2.set_ylabel(&#39;数量&#39;) sns.boxplot(x=&#39;Region&#39;, y=&#39;Price&#39;, data=df, ax=ax3) ax3.set_title(&#39;北京各大区二手房房屋总价&#39;,fontsize=15) ax3.set_xlabel(&#39;区域&#39;) ax3.set_ylabel(&#39;房屋总价&#39;) plt.show() 复制代码 使用了pandas的网络透视功能groupby分组排序。区域特征可视化直接采用 seaborn完成，颜色使用调色板palette 参数，颜色渐变，越浅说明越少，反之越多。 可以观察到： 二手房均价：西城区的房价最贵均价大约11万/平，因为西城在二环以里，且是热门学区房的聚集地。其次是东城大约10万/平，然后是海淀大约8.5万/平，其它均低于8万/平。 二手房房数量：从数量统计上来看，目前二手房市场上比较火热的区域。海淀区和朝阳区二手房数量最多，差不多都接近3000套，毕竟大区，需求量也大。然后是丰台区，近几年正在改造建设，有赶超之势。 二手房总价：通过箱型图看到，各大区域房屋总价中位数都都在1000万以下，且房屋总价离散值较高，西城最高达到了6000万，说明房屋价格特征不是理想的正太分布。 Size特征分析f, [ax1,ax2] = plt.subplots(1, 2, figsize=(15, 5)) # 建房时间的分布情况 sns.distplot(df[&#39;Size&#39;], bins=20, ax=ax1, color=&#39;r&#39;) sns.kdeplot(df[&#39;Size&#39;], shade=True, ax=ax1) # 建房时间和出售价格的关系 sns.regplot(x=&#39;Size&#39;, y=&#39;Price&#39;, data=df, ax=ax2) plt.show() 复制代码 Size 分布： 通过 distplot 和 kdeplot 绘制柱状图观察 Size 特征的分布情况，属于长尾类型的分布，这说明了有很多面积很大且超出正常范围的二手房。 Size 与 Price 的关系： 通过 regplot 绘制了 Size 和 Price 之间的散点图，发现 Size 特征基本与Price呈现线性关系，符合基本常识，面积越大，价格越高。但是有两组明显的异常点：1. 面积不到10平米，但是价格超出10000万；2. 一个点面积超过了1000平米，价格很低，需要查看是什么情况。 df.loc[df[&#39;Size&#39;]&lt; 10] 复制代码 经过查看发现这组数据是别墅，出现异常的原因是由于别墅结构比较特殊（无朝向无电梯），字段定义与二手商品房不太一样导致爬虫爬取数据错位。也因别墅类型二手房不在我们的考虑范围之内，故将其移除再次观察Size分布和Price关系。 df.loc[df[&#39;Size&#39;]&gt;1000] 复制代码 经观察这个异常点不是普通的民用二手房，很可能是商用房，所以才有1房间0厅确有如此大超过1000平米的面积，这里选择移除。 df = df[(df[&#39;Layout&#39;]!=&#39;叠拼别墅&#39;)&amp;(df[&#39;Size&#39;]&lt;1000)] 复制代码 重新进行可视化发现就没有明显的异常点了。 Layout特征分析f, ax1= plt.subplots(figsize=(20,20)) sns.countplot(y=&#39;Layout&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 这个特征真是不看不知道，各种厅室组合搭配，竟然还有9室3厅，4室0厅等奇怪的结构。其中，2室一厅占绝大部分，其次是3室一厅，2室2厅，3室两厅。但是仔细观察特征分类下有很多不规则的命名，比如2室一厅与2房间1卫，还有别墅，没有统一的叫法。这样的特征肯定是不能作为机器学习模型的数据输入的，需要使用特征工程进行相应的处理。 Renovation 特征分析df[&#39;Renovation&#39;].value_counts() 复制代码精装 11345 简装 8497 其他 3239 毛坯 576 南北` `20Name: Renovation, dtype: int64 发现Renovation装修特征中竟然有南北，它属于朝向的类型，可能是因为爬虫过程中一些信息位置为空，导致“Direction”朝向特征出现在这里，所以需要清除或替换掉。 # 去掉错误数据“南北”，因为爬虫过程中一些信息位置为空，导致“Direction”的特征出现在这里，需要清除或替换 df[&#39;Renovation&#39;] = df.loc[(df[&#39;Renovation&#39;] != &#39;南北&#39;), &#39;Renovation&#39;] # 画幅设置 f, [ax1,ax2,ax3] = plt.subplots(1, 3, figsize=(20, 5)) sns.countplot(df[&#39;Renovation&#39;], ax=ax1) sns.barplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax2) sns.boxplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax3) plt.show() 复制代码 观察到，精装修的二手房数量最多，简装其次，也是我们平日常见的。而对于价格来说，毛坯类型却是最高，其次是精装修。 Elevator 特征分析初探数据的时候，我们发现 Elevator 特征是有大量缺失值的，这对于我们是十分不利的，首先我们先看看有多少缺失值： misn = len(df.loc[(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;]) print(&#39;Elevator缺失值数量为：&#39;+ str(misn)) 复制代码Elevator 缺失值数量为：8237 这么多的缺失值怎么办呢？这个需要根据实际情况考虑，常用的方法有平均值/中位数填补法，直接移除，或者根据其他特征建模预测等。 这里我们考虑填补法，但是有无电梯不是数值，不存在平均值和中位数，怎么填补呢？这里给大家提供一种思路：就是根据楼层 Floor 来判断有无电梯，一般的楼层大于6的都有电梯，而小于等于6层的一般都没有电梯。有了这个标准，那么剩下的就简单了。 # 由于存在个别类型错误，如简装和精装，特征值错位，故需要移除 df[&#39;Elevator&#39;] = df.loc[(df[&#39;Elevator&#39;] == &#39;有电梯&#39;)|(df[&#39;Elevator&#39;] == &#39;无电梯&#39;), &#39;Elevator&#39;] # 填补Elevator缺失值 df.loc[(df[&#39;Floor&#39;]&gt;6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;有电梯&#39; df.loc[(df[&#39;Floor&#39;]&lt;=6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;无电梯&#39; f, [ax1,ax2] = plt.subplots(1, 2, figsize=(20, 10)) sns.countplot(df[&#39;Elevator&#39;], ax=ax1) ax1.set_title(&#39;有无电梯数量对比&#39;,fontsize=15) ax1.set_xlabel(&#39;是否有电梯&#39;) ax1.set_ylabel(&#39;数量&#39;) sns.barplot(x=&#39;Elevator&#39;, y=&#39;Price&#39;, data=df, ax=ax2) ax2.set_title(&#39;有无电梯房价对比&#39;,fontsize=15) ax2.set_xlabel(&#39;是否有电梯&#39;) ax2.set_ylabel(&#39;总价&#39;) plt.show() 复制代码 结果观察到，有电梯的二手房数量居多一些，毕竟高层土地利用率比较高，适合北京庞大的人群需要，而高层就需要电梯。相应的，有电梯二手房房价较高，因为电梯前期装修费和后期维护费包含内了（但这个价格比较只是一个平均的概念，比如无电梯的6层豪华小区当然价格更高了）。 Year 特征分析grid = sns.FacetGrid(df, row=&#39;Elevator&#39;, col=&#39;Renovation&#39;, palette=&#39;seismic&#39;,size=4) grid.map(plt.scatter, &#39;Year&#39;, &#39;Price&#39;) grid.add_legend() 复制代码 在Renovation和Elevator的分类条件下，使用 FaceGrid 分析 Year 特征，观察结果如下： 整个二手房房价趋势是随着时间增长而增长的； 2000年以后建造的二手房房价相较于2000年以前有很明显的价格上涨； 1980年之前几乎不存在有电梯二手房数据，说明1980年之前还没有大面积安装电梯； 1980年之前无电梯二手房中，简装二手房占绝大多数，精装反而很少； Floor 特征分析f, ax1= plt.subplots(figsize=(20,5)) sns.countplot(x=&#39;Floor&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 可以看到，6层二手房数量最多，但是单独的楼层特征没有什么意义，因为每个小区住房的总楼层数都不一样，我们需要知道楼层的相对意义。另外，楼层与文化也有很重要联系，比如中国文化七上八下，七层可能受欢迎，房价也贵，而一般也不会有4层或18层。当然，正常情况下中间楼层是比较受欢迎的，价格也高，底层和顶层受欢迎度较低，价格也相对较低。所以楼层是一个非常复杂的特征，对房价影响也比较大。 总结存在问题： 解决爬虫获取的数据源准确度问题； 需要爬取或者寻找更多好的售房特征； 需要做更多地特征工程工作，比如数据清洗，特征选择和筛选； 使用统计模型建立回归模型进行价格预测；","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.iamys.club/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"初识vue","slug":"vue基础","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-31T15:10:47.928Z","comments":true,"path":"2020/06/20/vue基础/","link":"","permalink":"https://www.iamys.club/2020/06/20/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"vue模块语法Vue概述声明式渲染&gt;组件系统&gt;客户端路由&gt;集中式状态管理&gt;项目构建 优点：易用、灵活、高效 Vue基本使用目标：能够说出Vue基本用法 vue的基本使用步骤 提供标签填充数据 引入vue.js库文件 可以使用vue的语法做功能 把vue提供的数据填充到标签中 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; //在页面中打印这段字符 } }); &lt;/script&gt;细节分析： 实例参数分析 el：元素的挂载位置（值可以是css选择器，也可以是DOM元素） data：模型数据（值是一个对象） 插值表达式用法 将数据填充到HTML标签中 插值表达式支持基本计算 vue代码运行原理分析 vue代码通过可以通过vue框架编译成原生js代码 Vue模板语法目标：能够说出Vue的模板语法 模板语法概述如何理解前端渲染：把数据填充得HTML中 前端渲染的方式 原生js拼接字符串 使用前端模板引擎 使用vue特有的模板语法 模板语法概述 插值表达式 指令 事件绑定 属性绑定 样式绑定 分支循环结构 指令什么是指令 指令的本质就是自定义属性 指令的格式:以v-开始 v-cloak指令用法先提供样式,再在插值表达式中添加v-cloak指令 &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-cloak&gt;{{msg}}&lt;/div&gt; &lt;/div&gt; 插值表达式存在的问题:闪动 如何解决该问题:使用v-cloak指令 解决问题的原理:先隐藏,替换好值之后显示最终的值 数据绑定指令 v-text填充纯文本 相比插值表达式更加简洁 v-html填充HTMl片段 存在安全问题 只能本网站内部可以用 v-pre填充原始信息 显示原始信息,跳过编译过程 数据的响应式 如何理解响应式? h5中的响应式就是屏幕尺寸变化导致的样式变化,数据的响应式就是数据的变化导致页面内容的变化 什么是数据绑定?将数据填充到标签中 v-once 只编译一次,显示内容之后不再具有响应式功能 &lt;div v-once&gt;{{info}} &lt;/div&gt;双向数据绑定什么是双向数据绑定?当在表单输入域输入字符是页面的内容也会有所变化. 双向数据绑定分析v-model指令 &lt;div id=&quot;app&quot;&gt; &lt;div v-text=&#39;uname&#39;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&#39;uname&#39;&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { uname: &#39;&#39; } }) &lt;/script&gt;MVVM设计思想M(model) 模型 js对象 V(view) 视图 页面的DOM VM(View-Model) 视图模型 Vue DOM监听+数据绑定 视图和模型可以通过视图模型相互访问,也就是DOM元素和js对象通过Vue相互转换 事件绑定vue如何处理事件用v-on指令实现事件绑定 事件函数的调用方式事件函数参数的传递 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{num}} &lt;/div&gt; &lt;button v-on:click=&#39;num++&#39;&gt;点击3&lt;/button&gt; &lt;!-- 事件绑定简写形式 --&gt; &lt;button @click=&#39;num++&#39;&gt;点击4&lt;/button&gt; &lt;!-- 事件绑定函数名 默认会传递事件对象 它为第一个参数 --&gt; &lt;button v-on:click=handle1&gt;点击1&lt;/button&gt; &lt;!-- 事件绑定函数调用 可以传递参数 事件对象必须是最后一个参数 参数名必须是$event --&gt; &lt;button v-on:click=handle2(123,456,$event)&gt;点击2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML); }, handle2: function(a, b, event) { // 调用参数必须写this，它指向实例对象 this.num++ console.log(a, b, event.target.innerHTML); } } }); &lt;/script&gt;事件修饰符.stop阻止冒泡 &lt;a v-on:click.stop=&#39;handle&#39;&gt;&lt;/a&gt;.prevent 阻止默认行为 &lt;a v-on:click.prevent=&#39;handle&#39;&gt;&lt;/a&gt;按键修饰符.enter回车键 &lt;input v-on:keyup.enter=&#39;submit&#39;&gt;.delete删除键 &lt;input v-on:keyup.delete=&#39;handle&#39;&gt;自定义按键修饰符全局config.keyCodes对象 Vue.config.keyCodes.f1=112属性绑定Vue如何动态处理数据v-bind指令实现动态绑定数据 &lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind动态绑定属性:是它的缩写 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt; &lt;!-- &lt;a :href=&quot;url&quot;&gt;百度&lt;/a&gt; --&gt; &lt;button v-on:click=&#39;handle&#39;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;http//www.baidu.com&#39; }, methods: { handle: function() { this.url = &#39;http://itcast.cn&#39;; } } }) &lt;/script&gt;v-model的底层实现原理 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&quot;handle&quot;&gt; //v-bind v-on &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;hello&#39; }, methods: { handle: function(event) { this.msg = event.target.value; } } }) &lt;/script&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;&gt; &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;样式绑定class样式处理对象语法 &lt;div v-bind:class=&quot;{active:isActive}&quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;style样式处理对象语法 &lt;div v-bind:style=&quot;{color:activeColor,fontSize:fontSize} &quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:style=&quot;[beseStyle,overrideingStyles]&quot;&gt;&lt;/div&gt;分支循环结构分支结构v-if和v-show的区别循环结构v-for遍历数组 &lt;li v-for=&#39;item in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;key的作用：帮助Vue区分不同的元素，从而提高性能 &lt;li :key=&#39;item.id&#39; v-for=&#39;{item,index} in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;基础案例简易计算器 通过v-nodel指令实现数值a和数值b的绑定 给计算按钮绑定事件,实现计算逻辑 将计算结果绑定到对应位置 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;简单计算器&lt;/h1&gt; 数字1：&lt;input type=&quot;text&quot; v-model=&#39;a&#39;&gt;&lt;br&gt; 数字2： &lt;input type=&quot;text&quot; v-model=&#39;b&#39;&gt;&lt;br&gt; &lt;button v-on:click=&#39;handle&#39;&gt;计算&lt;/button&gt; &lt;span v-text=&#39;result&#39;&gt;计算结果：&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { a: &#39;&#39;, b: &#39;&#39;, result: &#39;&#39; }, methods: { handle: function() { this.result = parseInt(this.a) + parseInt(this.b); } } }) &lt;/script&gt;tab栏切换 实现静态dUI效果： 用传统的方式实现标签结构和样式 基于数据重构UI效果：将静态的结构和样式重构基于Vue模板语法的形式，处理事件绑定和逻辑控制 &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;tab&quot;&gt; &lt;ul&gt; &lt;li v-on:click=&#39;change(index)&#39; :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}} &lt;/li&gt; &lt;/ul&gt; &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt; &lt;img :src=&quot;item.path&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { currentIndex: 0, //选项卡的当前索引 list: [{ id: 1, title: &#39;apple&#39;, path: &#39;images/01.jpg&#39; }, { id: 2, title: &#39;orange&#39;, path: &#39;images/02.jpg&#39; }, { id: 3, title: &#39;lemon&#39;, path: &#39;images/03.jpg&#39; }] }, methods: { change: function(index) { this.currentIndex = index; } } }) &lt;/script&gt;声明式编程：模板的结构和最终显示的效果基本一致 Vue常用特性目标：能够说出Vue的常用特性 表单操作 input单行文本 直接值文本域中添加v-model=’uname’,然后再到data里面给uname初始值 textarea多行文本 直接值文本域中添加v-model=’dect’,然后再到data里面给dect初始值 select下拉多选 单选方式 v-model=”occupation” 再到data里给一个初始值，多选方式 v-model=”occupation” multiple 数组的形式给初始值（给每个选项一个单独的value值） redio单选框 v-model=”gender ，data中给初始值（每个选项给一个value值） checkbox多选框 v-model=”hobby” data里以数组的方式给一个初始值（每个选项给一个单独的value值） 表单修饰符 number：转化为数值 trim：去掉开始和结尾空格 lazy：将input事件切换为change事件 &lt;input type=&quot;text&quot; v-model.number=&#39;age&#39;&gt;自定义指令当内置指令不满足要求时我们需要自定义指令 自定义的语法规则 //自定义获得焦点指令 Vue.directive(&#39;focus&#39;, { inserted: function(el) { //el表示指令所绑定的元素 el.focus(); } });自定义的指令用法 &lt;input type=&quot;text&quot; v-focus&gt;带参数的自定义属性 directives: { color: { bind: function(el, binding) { el.style.backgroundColor = binding.value; } }, focus: { //定义在实例中的局部指令 inserted: function(el) { el.focus(); } } }指令的用法 &lt;input type=&quot;text&quot; v-color=&quot;msg&quot;&gt; &lt;input type=&quot;text&quot; v-focus&gt;计算属性表达式可能比较复杂的时候，使用计算属性可以使模板内容更加简洁 计算属性的用法 computed: { reverseString: function() { return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;); //反转字符串 } }过滤器格式化数据，比如将字符串格式转换为首字符大写，将日期格式 转化为指定的格式 自定义过滤器 Vue.filter(&#39;upper&#39;, function(val) { return val.charAt(0).toUpperCase() + val.slice(1); //将第一个字母转换为大写slice字符截取 });过滤器的用法 &lt;div&gt;{{msg|upper}}&lt;/div&gt; &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; &lt;div :abc=&quot;msg|upper&quot;&gt;测试&lt;/div&gt;局部过滤器 filters: { upper: function(val) { return val.charAt(0).toUpperCase() + val.slice(1); } }带参数的过滤器Vue.filter(&#39;format&#39;,function(Value,arg)){ //value就是过滤器传过来的参数 }过滤器的使用&lt;div&gt;{{data|format('yyyy-MM-dd')}}&lt;/div&gt;侦听器在数据变化使执行异步或开销较大的操作可以使用侦听器 侦听器的用法 methods: { checkName: function(uname) { //使用定时任务模拟接口调用 var that = this; setTimeout(function() { if (uname == &#39;admin&#39;) { that.tip = &#39;用户名已存在，请更换一个&#39;; } else { that.tip = &#39;用户名可以使用&#39;; } }, 1000); } }, watch: { uname: function(val) { //调用后台接口验证用户名的合法性 this.checkName(val); //修改提示信息 this.tip = &#39;用户名正在验证…&#39;; } }生命周期主要阶段 挂载（初始化相关属性） beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 created 在实例创建完成后立即被调用 beforeMount 在挂载开始之前被调用 mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子 更新（元素或组件的变更操作） beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前 updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子 销毁（销毁相关属性）关属性） beforeDestroy 实例销毁之前调用 destroyed 实例销毁之后调用 综合案例目标：能够基于Vue实现案例效果","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"}]},{"title":"Ajax","slug":"Ajax","date":"2020-05-07T16:00:00.000Z","updated":"2020-05-08T04:37:40.558Z","comments":true,"path":"2020/05/08/Ajax/","link":"","permalink":"https://www.iamys.club/2020/05/08/Ajax/","excerpt":"","text":"Ajax的作用浏览器提供的一个方法，可以实现无刷新更新数据，提高用户浏览应用的体验。 Ajax的应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 Ajax运行原理及实现Ajax运行原理Ajax相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新数据，从而提高用户体验。 Ajax的实现步骤 创建Ajax对象 var xhr = new XHLHttpRequest() 告诉Ajax请求地址以及请求方式 xhr.open(&#39;get&#39;,&#39;http://localhost:3000&#39;) 发送请求 xhr.send() 获取服务器端给客服端的响应数据 xhr.onload = function(){ console.log(xhr.responseText) }服务器端响应的数据格式服务器端大多数情况下会以JSON对象作为响应数据的格式，客户端拿到数据时要将JSON数据和HTML字符串进行拼接，再把拼接好的结果展示在页面 在http请求和响应的过程中，无论时请求参数还是请求参数还是响应内容，如果时对象类型，最终都会被转换为对象字符串进行传输。 JSON.parse() //将json字符串转换为json对象 JSON.stringify() // 将json对象转换为json字符串 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json。 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 请求参数传递 GET请求方式 xhr.open(&#39;get&#39;,&#39;http://www.example.com?name=zhangsan&amp;age=20&#39;) POST请求方式 xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;) xhr.send(&#39;name=zhangsan&amp;age=20&#39;)请求报文 在http请求和响应的过程中传递的数据块就叫做报文，，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。 请求参数的格式 application/x-www-form-urlencoded name=zhangsan&amp;age=20&amp;sex=男 application/json {name: &#39;zhangsan&#39;, age: &#39;20&#39;, sex: &#39;男&#39;} 获取服务器的响应Ajax状态码在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化(还没有调用open()) 1：请求已经建立，但是还没有发送(还没有调用send()) 2：请求已经发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已经完成，可以获取并使用服务器的响应了 xhr.readyState // 获取Ajax状态码onreadystatechange事件当Ajax状态码发生变化时自动触发该事件 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。 // 当Ajax状态码发生变化时 xhr.onreadystatechange = function () { // 判断当Ajax状态码为4时 if (xhr.readyState == 4) { // 获取服务器端的响应数据 console.log(xhr.responseText); } }Ajax错误处理 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 ​ 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 网络畅通，服务器端没有接收到请求，返回404状态码。 ​ 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 ​ 服务器端错误，找后端程序员进行沟通。 网络中断，请求无法发送到服务器端。 ​ 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 低版本ie浏览器的缓存问题解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同 xhr.open(&#39;get&#39;, &#39;http://www.example.com?t=&#39; + Math.random());Ajax异步编程 一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情。 落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 模板引擎使用步骤1.下载art-template模板引擎文件，并引入 &lt;script src=&quot;./js/template-web.js&quot;&gt;&lt;/script&gt;2.准备模板 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/script&gt; 3.告诉模板引擎将哪一个模板和哪个数据进行拼接 var html = template(&#39;tpl&#39;, {username: &#39;zhangsan&#39;, age: &#39;20&#39;});4.将拼接好的html字符串添加到页面中 document.getElementById(&#39;container&#39;).innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt; {{ username }} &lt;/div&gt; &lt;/script&gt;FormData 对象的作用1.模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 2.异步上传二进制文件 FormData 对象的使用 1.有一个HTML表单 2.将HTML表单转换为formData对象 var form = document.getElementById(&#39;form&#39;); var formData = new FormData(form);3.提交表单对象 xhr.send(formData)注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析。 formData对象的实例方法 获取表单对象中的属性值 formData.get(&#39;key&#39;) 设置表单对象中的属性的值 formData.set(&#39;key&#39;,value) 删除表单对象中属性的值 formData.delete(&#39;key&#39;) 像表单对象中追加属性值 formData.append(&#39;key&#39;,&#39;value&#39;)注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 FormData二进制文件上传&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt; var file = document.getElementById(&#39;file&#39;) // 当用户选择文件的时候 file.onchange = function () { // 创建空表单对象 var formData = new FormData(); // 将用户选择的二进制文件追加到表单对象中 formData.append(&#39;attrName&#39;, this.files[0]); // 配置ajax对象，请求方式必须为post xhr.open(&#39;post&#39;, &#39;www.example.com&#39;); xhr.send(formData); }FormData文件上传进度展示 // 当用户选择文件的时候 file.onchange = function () { // 文件上传过程中持续触发onprogress事件 xhr.upload.onprogress = function (ev) { // 当前上传文件大小/文件总大小 再将结果转换为百分数 // 将结果赋值给进度条的宽度属性 bar.style.width = (ev.loaded / ev.total) * 100 + &#39;%&#39;; } }FormData文件上传图片即使预览 xhr.onload = function () { var result = JSON.parse(xhr.responseText); var img = document.createElement(&#39;img&#39;); img.src = result.src; img.onload = function () { document.body.appendChild(this); } }同源政策什么时同源：如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 同源的目的：同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 使用JSONP解决同源限制问题 将不同源的服务器端请求地址写在 script 标签的 src 属性中 &lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 const data = &#39;fn({name: &quot;张三&quot;, age: &quot;20&quot;})&#39;; res.send(data); 在客户端全局作用域下定义函数 fn，并进行处理 function fn (data) { console.log(data); } JSONP代码优化1.客户端需要将函数名称传递到服务器端。 2.将 script 请求的发送变成动态请求。 3.封装 jsonp 函数，方便请求发送。 4.服务器端代码优化之 res.jsonp 方法。 CORS跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 浏览器端请求头 origin: http://localhost:3000服务器端响应头 Access-Control-Allow-Origin: &#39;http://localhost:3000&#39; Access-Control-Allow-Origin: &#39;*&#39; //Node服务器设置响应头实例 app.use((req, res, next) =&gt; { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST&#39;); next(); })jQuery与Ajax$.ajax() :发送Ajax请求 $.ajax({ type: &#39;get&#39;, url: &#39;http://www.example.com&#39;, data: { name: &#39;zhangsan&#39;, age: &#39;20&#39; }, contentType: &#39;application/x-www-form-urlencoded&#39;, beforeSend: function () { return false }, success: function (response) {}, error: function (xhr) {} });$.ajax: 发送jsonp请求$.ajax({ url: &#39;http://www.example.com&#39;, // 指定当前发送jsonp请求 dataType: &#39;jsonp&#39;, // 修改callback参数名称 jsonp: &#39;cb&#39;, // 指定函数名称 jsonCallback: &#39;fnName&#39;, success: function (response) {} })serialize方法：将表单中的数据自动拼接成字符串类型的参数，获取用户在表单中输入的值 var params = $(&#39;#form&#39;).serialize(); // name=zhangsan&amp;age=30$.get()和$.post()方法：$.get方法用于发送get请求，$.post方法用于发送post请求 全局事件只要页面有Ajax请求被发送，对应的全局事件就会触发 .ajaxStart() // 当请求开始发送时触发 .ajaxComplete() // 当请求完成时触发NProgress：进度条动画NProgress.start(); // 进度条开始运动 NProgress.done(); // 进度条结束运动RESTful API 一套关于请求风格的规范 GET： 获取数据 POST： 添加数据 PUT： 更新数据 DELETE： 删除数据","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"}]},{"title":"Express框架","slug":"Express框架","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-20T12:36:41.432Z","comments":true,"path":"2020/04/20/Express框架/","link":"","permalink":"https://www.iamys.club/2020/04/20/Express%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express是一个基于Node平台的web应用开放框架，他提供了一系列的强大特性，帮助你创建各种web应用。我们可以使用npm install express 命令下载 Express框架特性 提供了方便简洁的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供中间件机制有效控制HTTP请求 拥有大量中间件对功能进行扩展 // 引入express框架 const express = require(&#39;express&#39;); // 创建网站服务器 const app = express(); app.get(&#39;/&#39; , (req, res) =&gt; { // send() // 1. send方法内部会检测响应内容的类型 // 2. send方法会自动设置http状态码 // 3. send方法会帮我们自动设置响应的内容类型及编码 res.send(&#39;Hello. Express&#39;); }) // 监听端口 app.listen(3000);中间件中间件就是一堆方法，可以接受客户端放来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 中间件由两部分构成，中间件方法以及请求处理函数；中间件方法由Exprss提供，负责拦截请求，请求函数有开发人员提供，负责处理请求。 app.get(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理get请求 app.post(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理post请求可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 app.get(&#39;/request&#39;, (req, res, next) =&gt; { req.name = &quot;张三&quot;; next(); }); app.get(&#39;/request&#39;, (req, res) =&gt; { res.send(req.name); });app.use中间件用法app.use 匹配所有请求方式，可以直接传入请求处理函数，代表接受所有请求。第一个参数可以省略表示通配。 app.use(&#39;/admin&#39;, (req, res, next) =&gt; { console.log(req.url); next(); });中间件的应用 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。 自定义404页面 错误处理中间件在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。 app.use((err, req, res, next) =&gt; { res.status(500).send(&#39;服务器发生未知错误&#39;); })当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件 app.get(&quot;/&quot;, (req, res, next) =&gt; { fs.readFile(&quot;/file-does-not-exist&quot;, (err, data) =&gt; { if (err) { next(err); } }); });捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。 异步函数执行如果发生错误可以通过 try catch 捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。 app.get(&quot;/&quot;, async (req, res, next) =&gt; { try { await User.find({name: &#39;张三&#39;}) }catch(ex) { next(ex); } });Express请求处理模块化路由const home = express.Router(); // 为路由对象匹配请求路径 app.use(&#39;/home&#39;, home); // 创建二级路由 home.get(&#39;/index&#39;, (req, res) =&gt; { res.send(&#39;欢迎来到博客首页页面&#39;) }) // admin.js const admin = express.Router(); admin.get(&#39;/index&#39;, () =&gt; { res.send(&#39;欢迎来到博客管理页面&#39;); }); module.exports = admin;const admin = require(&#39;./route/admin.js&#39;); app.use(&#39;/admin&#39;, admin);GET 参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。 // 接收地址栏中问号后面的参数 // 例如: http://localhost:3000/?name=zhangsan&amp;age=30 app.get(&#39;/&#39;, (req, res) =&gt; { console.log(req.query); // {&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;} });POST参数的获取Express中接收post请求参数需要借助第三方包 body-parser。 // 引入body-parser模块 const bodyParser = require(&#39;body-parser&#39;); // 配置body-parser模块 // extended: false 方法内部使用querystring模块处理请求参数的格式 // extended: true 方法内部使用第三方模块qs处理请求参数的格式 app.use(bodyParser.urlencoded({ extended: false })); // 接收请求 app.post(&#39;/add&#39;, (req, res) =&gt; { // 接收请求参数 console.log(req.body); }) 路由参数 app.get(&#39;/find/:id&#39;, (req, res) =&gt; { console.log(req.params); // {id: 123} });访问的是localhost:3000/find/123 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。 app.use(express.static(&#39;public&#39;));这样public下的静态资源就可以访问了 Express-art-template模板引擎模板引擎 为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。 使用npm install art-template express-art-template命令进行安装。 // 当渲染后缀为art的模板时 使用express-art-template app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)); // 设置模板存放目录 app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 渲染模板时不写后缀 默认拼接art后缀 app.set(&#39;view engine&#39;, &#39;art&#39;); app.get(&#39;/&#39;, (req, res) =&gt; { // 渲染模板 res.render(&#39;index&#39;); }); app.locals对象将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。 app.locals.users = [{ name: &#39;张三&#39;, age: 20 },{ name: &#39;李四&#39;, age: 20 }]","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"mongoDB数据库","slug":"mongoDB接数据库","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-20T12:38:47.286Z","comments":true,"path":"2020/04/17/mongoDB接数据库/","link":"","permalink":"https://www.iamys.club/2020/04/17/mongoDB%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"术语 解释说明 database 数据库，可建立多个 collection 集合，一组数据，相当于js里的数组 document 文档，一条具体的数据，相当于js里的对象 filed 字段，文档中的属性名称，相当与js中的对象属性 如何连mongoDB接数据库 下载mongoos第三方模块npm install mongoose 启动 ner start mongoDB 引入mongoose第三方模块，用来操作数据库 用connect方法来连接数据库，参数为mongodb://localhost/playground，最后一个是数据库名写上就会自动创建 分别用.then和.catch对数据库连接成功或失败一个反馈 const mongoose = require(&#39;mongoose&#39;) mongoose.connect(&#39;mongoose://localhost/playground&#39;) .then(() =&gt; console.log(&#39;数据库连接成功&#39;)) .catch(() =&gt; console.log(&#39;数据库连接失败&#39;))如何创建一个集合以及向集合插入文档 创建集合规则，用new实例化mongoose，用Schema方法添加规则，规则为字段名和类型 创建集合，model方法第一个参数是集合名第二个参数是集合规则 创建文档，用new实例化集合，参数为一个对象每一项是具体的字段和值 将文档保存到数据库，文档名.save() const personSchema = new mongoose.Schema({ name: String, age: Number, hobbies: [String] }) const Person = mongoose.model(&#39;Person&#39;, personSchema) const person = new Person({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) person.save()集合插入文档的另一种方式之前我们插入文档是用new实例化集合，还有一个方式是用集合.create方法参数是一个对象，里面是具体的字段和值，可以用.then查看结果。 Person.create({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) .then(result =&gt; {console.log(result);})文档查询文档查询之前可以先建立一个用户信息文件如user.json { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f1e5aeb04b22f8460965&quot; }, &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;, &quot;橄榄球&quot;], &quot;email&quot;: &quot;zhangsan@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f236aeb04b22f8460967&quot; }, &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 10, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;], &quot;email&quot;: &quot;lisi@itcast.cn&quot;, &quot;password&quot;: &quot;654321&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f267aeb04b22f8460968&quot; }, &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;hobbies&quot;: [&quot;敲代码&quot;], &quot;email&quot;: &quot;wangwu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f294aeb04b22f8460969&quot; }, &quot;name&quot;: &quot;赵六&quot;, &quot;age&quot;: 50, &quot;hobbies&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;], &quot;email&quot;: &quot;zhaoliu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2b6aeb04b22f846096a&quot; }, &quot;name&quot;: &quot;王二麻子&quot;, &quot;age&quot;: 32, &quot;hobbies&quot;: [&quot;吃饭&quot;], &quot;email&quot;: &quot;wangermazi@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2d9aeb04b22f846096b&quot; }, &quot;name&quot;: &quot;狗蛋&quot;, &quot;age&quot;: 14, &quot;hobbies&quot;: [&quot;打豆豆&quot;], &quot;email&quot;: &quot;goudan@163.com&quot;, &quot;password&quot;: &quot;123456&quot; }创建好集合之后用导入数据：mongoimport -d 数据库名 -c 集合名 --file 要导入文件的路径 然后再找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。 find()查询指定集合的所有文档 Person.find().then(result =&gt; console.log(result))find({条件})查询指定集合中满足条件的文档 Person.find({name:&#39;李四&#39;}).then(result=&gt;console.log(result))find({字段:{$gt:开始范围 , $lt: 结束范围}})查询字段位于之间的文档 &amp;lt小于 &amp;gt大于 Person.find({age:{$gt:20,$lt40}}).then(result=&gt;console.log(result))find({字段:{$in:包含项}}) Person.find({hobbies:{$in:[&#39;sing&#39;]}}).then(result=&gt;console.log(result))find().select(&#39;字段1，字段2..&#39;)查询指定字段，字段前加-，可以去除字段 Person.find().select(&#39;name,age,-id&#39;).then(result=&gt;console.log(result))find().sort(&#39;排序字段&#39;)默认按升序排序，加-按降序排序 Person.find().sort(&#39;-age&#39;).then(result=&gt;console.log(result))find().skip(跳过的条数).limit(限制显示结果的条数) Person.find.skip(2).limit(3).then(result=&gt;console.log(result))findOne()返回指定集合第一个文档 Person.findOne().then(result=&gt;console.log(result))findOne({条件})返回指定集合满足条件的第一个文档 Person.findOne({age:14}).then(result=&gt;console.log(result))删除文档查找一条文档并且删除，返回的是删除的文档，匹配多个文档会删除第一条 Person.findOneAndDelete({name:&#39;张三&#39;}).then(result =&gt; console.log(result))删除多个文档，不加条件会删除全部文档 Person.deleteMany({}).then(result =&gt; console.log(result))更新文档更新一条文档 Person.updateOne({ name: &#39;李四&#39; }, { name: &#39;李小四&#39;, age: 18 }).then(result =&gt; console.log(result))更新全部文档 Person.updateMany({}, { age: 0 }).then(result =&gt; console.log(result))mongoose验证在集合规则中有很多验证规则 required必填项，typt字段类型，minlength最小长度，maxlength最大长度，min最小值，max最大值，trim:true去掉首尾空格，default默认值，enum:{values:[]}枚举，validate:{validator:v=&gt;{return v&amp;&amp;v.length&gt;4}}自定义验证程序 message错误提示的获得，在向集合插入文档时的错误信息定义成如下 .catch(error =&gt; { // 获取错误信息对象 const err = error.errors; // 循环错误信息对象 for (var attr in err) { // 将错误信息打印到控制台中 console.log(err[attr][&#39;message&#39;]); } })集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。 使用id对集合进行关联 使用populate方法进行关联集合查询 const userSchema = new mongoose.Schema({ name: { type: String, required: true } }); const postSchema = new mongoose.Schema({ title: String, author: { //类型为id，固定写法 type: mongoose.Schema.Types.ObjectId, //关联集合user ref: &#39;User&#39; } }) const Post = mongoose.model(&#39;Post&#39;, postSchema); const User = mongoose.model(&#39;User&#39;, userSchema) Post.create({ title: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39; }).then(result =&gt; console.log(result)); User.create({ name: &#39;李四&#39; }).then(result =&gt; console.log(result)) //populate()关联集合查询 Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"node.js","slug":"node.js","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-20T12:40:02.383Z","comments":true,"path":"2020/04/16/node.js/","link":"","permalink":"https://www.iamys.club/2020/04/16/node.js/","excerpt":"","text":"node概念node是基于Chrome V8引擎的JavaScript代码运行环境，全局对象是globle，在node环境下使用node命令执行后缀为.js的文件即可 CommonJScommonJS是为js的表现制定规范，因为js没有模块化系统，标准库较少，缺乏包管理工具，CommonJS应运而生，它希望js可以在任何地方运行而不只是浏览器中，从而达到一些后端语言具有开发大型应用的能力。 commonJS与Node.js的关系：CommonJS时模块化的标准，Node.js是CommonJS（模块化）的实现 应用 服务器端js的应用程序Node.js 命令行工具 桌面图形应用程序 node组成ECMAScript和node环境提供的附加API 模块化开发javasript使用存在文件依赖和命名冲突的问题，因而要使用模块化开发，模块化开发的含义是一个功能就是一个模块多个模块可以组成完整的应用，抽离一个模块不会影响其他模块的运行。node.js规定一个JavaScript就是一个模块，模块内部定义的变量和函数外部无法得到，需要使用exports对象进行成员导出，require方法导入其他模块。 模块的导入导出 导出 exports module.exports 两者之间的关系 module.exports 是真正的接口exports是一个辅助工具如果module.exports为空，那么所有的exports属性和方法都赋值module.exports如果module.exports具有任何方法和属性，则exports会被忽略 导入 require 模块 核心模块 node自带的模块加载速度快 http模块 // 引用系统模块 const http = require(&#39;http&#39;); // 创建web服务器 const app = http.createServer(); // 当客户端发送请求的时候 app.on(&#39;request&#39;, (req, res) =&gt; { // 响应 res.end(&#39;&lt;h1&gt;hi, user&lt;/h1&gt;&#39;); }); // 监听3000端口 app.listen(3000); console.log(&#39;服务器已启动，监听3000端口，请访问 localhost:3000&#39;) 请求方式 get 请求数据 数据处理 参数放在地址栏中 参数获取需要借助系统模块url 客户端请求途径：浏览器地址栏 link标签的href属性 script标签的src属性 img标签的src属性 const http = require(&#39;http&#39;); // 导入url系统模块 用于处理url地址 const url = require(&#39;url&#39;); const app = http.createServer(); app.on(&#39;request&#39;, (req, res) =&gt; { // 将url路径的各个部分解析出来并返回对象 // true 代表将参数解析为对象格式 let {query} = url.parse(req.url, true); console.log(query); }); app.listen(3000);​ post 发送数据 实现某种功能 参数再请求体中 获取需要data和end事件 使用querystringstring系统模块将参数转为对象 ​ 客户端请求途径：Form表单提交 // 导入系统模块querystring 用于将HTTP参数转换为对象格式 const querystring = require(&#39;querystring&#39;); app.on(&#39;request&#39;, (req, res) =&gt; { let postData = &#39;&#39;; // 监听参数传输事件 req.on(&#39;data&#39;, (chunk) =&gt; postData += chunk;); // 监听参数传输完毕事件 req.on(&#39;end&#39;, () =&gt; { console.log(querystring.parse(postData)); }); });请求地址 app.on(&#39;request&#39;, (req, res) =&gt; { req.headers // 获取请求报文 req.url // 获取请求地址 req.method // 获取请求方法 });http状态码 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 url模块 parse 获取地址信息 resolve 追加或替换地址 formal 根据地址信息获得原url信息 fs文件管理 fs.stats 检测是文件还是文档 isDirctory() 是否文档 isFile() 是否文件 fs.mkdir 创建文档 fs.writeFile 创建写入文件 fs.appendFile 追加文件 fs.readdFile 读取文件 fs.readdir 读取文档 fs.rename 重命名或者剪切 fs.rmdir 删除文档 fs.unlink 删除文件 fs.createReadStream 读取流 on读取 fs.createWriteStream 写入流 write写入 end写完 on完成 path模块 path join() 拼接模块 __dirname 当前文件的绝对路径 文件模块用户自己编写的模块，动态加载运行速度相对较慢 模块的加载机制1.require方法根据模块路径查找模块，如果是完整路径，直接引入模块。2.如果模块后缀省略，先找同名JS文件再找同名JS文件夹3.如果找到了同名文件夹，找文件夹中的index.js4.如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件5.如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到 常用的第三方包第三方模块：别人已经写好的，具有特定功能的，我们可以下载直接使用的模块，通常是有多个文件组合在一起放置自在一个文件夹中，又名包。有两种存在形式，以js文件的形式存在，提供项目具体的api接口。以命令行工具存在，辅助项目开发。npmjs.com第三方模块存储和分发厂库 npm：node的第三方模块管理工具下载：npm install/i 模块名卸载：npm uninstall package 模块名命令行工具：全局安装-g 可在计算机任何一个地方使用它库文件：本地安装 nodemon：命令行工具辅助项目开发下载：npm install -g nodemon命令行工具用nodemon命令替代node命令执行文件自动监听文件是否更新，如果更新就自动执行。 nrm ：下载地址切换工具下载：npm install nrm -g查询下载地址：nrm ls切换下载地址：nrm use 下载地址名 一般都是用淘宝镜像来安装 npm install -g cnpm --registry=https://registry.npm.taobao.orgGlup ：基于node的前端构建工具作用：将机械化的操作编写成任务，想要执行这些任务时，可以用一个命令任务就自动执行了，提高开发效率。 具体应用：项目上线，HTML CSS JS文件的压缩合并。 语法转换es6 less之类的 公共文件抽离 修改文件浏览器自动刷新 使用：npm install gulp下载gulp库文件，在项目根目录下建立gulpfile.js文件，用``src目录放置源文件，dist目录放置构建后文件，在gulpfile.js文件中编写任务，在命令行工具执行gulp任务 const gulp = require(&#39;gulp&#39;); // 复制文件夹 gulp.task(&#39;copy&#39;, () =&gt; { gulp.src(&#39;./src/images/*&#39;) .pipe(gulp.dest(&#39;dist/images&#39;)); gulp.src(&#39;./src/lib/*&#39;) .pipe(gulp.dest(&#39;dist/lib&#39;)) }); // 构建任务 gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]); gulp中提供的方法 gulp.src():获取任务要处理的文件 gulp.dest() 输出文件 gulp.task() 建立gulp任务 gulp.watach() 监控文件的变化 .pope() 放置要处理的文件 gulp插件插件网址：www.npmjs.com 插件用法：下载 如：npm install gulp-htmlmin 引用：如：require gulp-htmlmin 调用 npm install gulp-cil -g 安装gulp的命令行工具 在文件名为.glupfile.js里面编写任务，相同路径下建立src文件夹存放源文件，在dist目录下存放修改后的文件 gulp-htmlmin html文件的压缩 const gulp = require(&#39;gulp&#39;); const htmlmin = require(&#39;gulp-htmlmin&#39;); const fileinclude = require(&#39;gulp-file-include&#39;); // html任务 // 1.html文件中代码的压缩操作 // 2.抽取html文件中的公共代码 gulp.task(&#39;htmlmin&#39;, () =&gt; { gulp.src(&#39;./src/*.html&#39;) .pipe(fileinclude()) // 压缩html文件中的代码 .pipe(htmlmin({ collapseWhitespace: true })) .pipe(gulp.dest(&#39;dist&#39;)); }); gulp-file-include 公共文件包含 先把公共部分提取到一个单独的文件里，再把需要引入公共部分的地方写上 @@include (‘公共文件的路径’) - gulp-csso 压缩css - gullp-less less语法转换 ``` const less = require(&#39;gulp-less&#39;); const csso = require(&#39;gulp-csso&#39;); // css任务 // 1.less语法转换 // 2.css代码压缩 gulp.task(&#39;cssmin&#39;, () =&gt; { // 选择css目录下的所有less文件以及css文件 gulp.src([&#39;./src/css/*.less&#39;, &#39;./src/css/*.css&#39;]) // 将less语法转换为css语法 .pipe(less()) // 将css代码进行压缩 .pipe(csso()) // 将处理的结果进行输出 .pipe(gulp.dest(&#39;dist/css&#39;)) }); ``` - gulp-bable js语法转换 - gulp-uglify 压缩混淆js ``` const babel = require(&#39;gulp-babel&#39;); const uglify = require(&#39;gulp-uglify&#39;); // js任务 // 1.es6代码转换 // 2.代码压缩 gulp.task(‘jsmin’, () =&gt; { gulp.src(‘./src/js/*.js’) .pipe(babel({ // 它可以判断当前代码的运行环境 将代码转换为当前运行环境所支持的代码 presets: [‘@babel/env’] })) .pipe(uglify()) .pipe(gulp.dest(‘dist/js’)) }); ``` - browsersync 浏览器实时同步package.json文件作用：项目描述文件，记录当前项目信息，可使用npm init -yes/y命令生成。 node_modules文件夹的问题Node规范将模块文件都放在node_modules这个目录 但是如果文件夹和文件过多过碎，我们要把整体文件夹拷贝给别人的时候传输速度会很慢。复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致以免运行报错。 项目依赖项目开发和运营上线都需要依赖的第三方包，使用npm install 包名下载的文件会默认添加到package.js文件的dependencies字段中 dependencies npm install 下载 开发依赖项目开发阶段需要的依赖，线上运营不需要的第三方包，称为开发依赖使用npm install 包名 --save-dev/-D命令将包添加到devDependencies字段中 devDependencies npm install –production 下载 package-lock.js文件的作用锁定包的版本，确保再次下载时不会因为包版本不同而产生问题加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 Node.js异步编程同步API：只有当前API执行完成后，才能继续执行下一个API，可以从返回值拿到API的执行结果 异步API：当前API的执行不会阻塞后续代码的执行，使用回调函数(自己定义的函数别人调用)可以获取异步API的执行结果 Promise出现的目的是解决Node.js异步编程中回调地狱(也就是后面异步API依赖当前异步API的调用，造成一层层嵌套的关系)的问题。 异步函数异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 async关键字 const fn = async () =&gt; {};async function fn () {} 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象 写其他类型的API是不不可以的 await关键字可是暂停异步函数向下执行 直到promise返回结果","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"}]},{"title":"初识jQuery","slug":"jQuery","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-11T14:07:22.863Z","comments":true,"path":"2020/04/10/jQuery/","link":"","permalink":"https://www.iamys.club/2020/04/10/jQuery/","excerpt":"","text":"初始jQuery什么是jQueryjQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）； jQuery的优点 轻量级。核心文件才几十kb，不会影响页面大的加载速度 跨浏览器兼容。基本兼容了现在主流大的浏览器 链式编程，隐式迭代 ( 隐式迭代就是把匹配的所有元素内部进行遍历循环) 对事件、样式、动画支持，大大简化大的DOM操作 支持插件扩展开发。有着丰富大的第三方插件，如树形菜单、日期控件、轮播图等 免费、开源 简单的使用jQuery1.jQuery的入口函数 $(function() { $(&#39;div&#39;).hide();//此处是DOM加载完成的入口，相当与原生的DOMContentLoaded })2.jQuery的顶级对象$ ​ $是jQuery的别称，在代码中jQuery和$可以互换 ​ $是jQuery的顶级对象，相当于原生的的window，帮元素利用$包装成jQuery对象，就可以调用jQuery的方法。 DOM对象和jQuery对象的区别 用原生js获取来的对象就是DOM对象 var myDiv = document.querySelector(&#39;div&#39;); // myDiv 是DOM对象 jQuery方法获取的元素就是jQuery对象 $(&#39;div&#39;); // $(&#39;div&#39;)是一个jQuery 对象 jQuery对象的本质是：利用$对DOM对象大的包装后生产的对象（伪数组形式储存） DOM对象和jQuery对象之间是可以相互转换的 因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装。要是想要这些属性和方法需要把和jQuery对象转换成DOM对象才能使用 DOM对象转换为jQuery对象 $(DOM对象) $(&#39;div&#39;) jQuery对象转换为DOM对象(两种方式) $(&#39;div&#39;)[index] //index是索引号$(&#39;div&#39;).get(index)jQuery的基本操作能写出常用的jQuery选择器基础选择器$(&quot;选择器&quot;) //直接写css选择器，但是一定要加双引号 用法 名称 描述 $(“#id”) Id选择器 获取指定ID元素 $(“*”) 全选选择器 匹配所有元素 $(“.class”) 类选择器 获取同一类元素 $(“div”) 标签选择器 获取同一类标签的所有元素 $(“div,p,li”) 并集选择器 选取多个元素 $(“li.current”) 交集选择器 交集元素 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”) 使用&gt;号，获取亲儿子层级的元素；注意不会获取到孙子层级的元素 后代选择器 $(“ul li”) 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子 筛选选择器 语法 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :ed(index) $(“li:ed(2)”) 获取li元素中，选择索引号为2的元素 :odd $(“li:odd”) 获取li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取li元素中,选择索引号为偶数的元素 筛选方法(重点) 语法 用法 说明 parent() $(“li”).parent(); 查找父级 children(selector) $(“ul”).children(“li”); 相当于$(“ul&gt;li”),最近一级(亲儿子) find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“.first”).siblings(“li”); 查找兄弟节点。不包括自己 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(“.last”).pravAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(“div”).hasClass(“protected”) 查找当前元素是否含有某个特定的类，如果有则返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index从0开始 重点记住：parent() children() find() siblings() eq() 能够操作jQuery样式操作css方法jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。 1.参数只写属性名，则返回属性值 $(this).css(&quot;color&quot;);2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号 $(this.css(&quot;color&quot;,&quot;red&quot;);3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不加引号 $(this).css(&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;)设置类样式方法作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;);2.移除类 $(&quot;div&quot;).removeClass(&quot;current&quot;);3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;);类操作与ClassName区别原生js中的ClassName会覆盖原先里面的类名 jQuery里面的类操作只是对指定类进行操作，不会影响原先的类名。 能够写出常用的jQuery动画1.显示隐藏 show() hide() toggle()show([speed,[easing],[fn]]) //(1) 参数都可以省略，无动画直接显示 (2)speed：三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值 (3)easing:(Optional)用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次 下面的相同2.滑动 sideDown() sideUp() sideToggle()3.淡入淡出 fadeIn() fadeOut() fadeToggle() fadeTo()fadeTo(speed,opacity,[easing],[fn]) //(1)opacity 透明度必须写，取值0-1之间 (2)speed 三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值必须写4.自定义动画 animate()animate(params,[speed],[easing],[fn]) //params 想要更改的属性，以对象的形式传递，必须写，属性名可以不写引号，复合属性采用驼峰命名方式5.动画或效果队列及其停止排队方法动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。 stop() //用于停止动画或者效果，一定要写到动画前面，相当于停止结束上一次的动画能够操作jQuery属性设置获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性； 1.获取属性的语法prop(&quot;属性&quot;)2.设置属性语法prop(&quot;属性&quot;，&quot;属性值&quot;)设置或获取元素自定义属性attr()用户给元素添加大的属性； 1.获取属性语法attr(&quot;属性&quot;) //类似原生getAttribute2.设置属性语法attr(&quot;属性&quot;,&quot;属性值&quot;) //类似原生setAttribute数据缓存data()data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都会移除。 1.附加数据语法data(&quot;name&quot;,&quot;value&quot;) //向被选元素附加数据2.获取数据语法data(&quot;name&quot;) //向被选元素获取数据同时还可以读取HTML5自定义属性data-index，得到的是数字型 能够操作jQuery元素内容文本值主要针对元素的内容还有表单的值操作 1.普通元素内容html()(相当于原生inneHTML)html() //获取元素的内容html(&quot;内容&quot;) //设置元素的内容2.普通元素文本内容text() (相当与原生innerText)text() //获取元素文本内容text(&quot;文本内容&quot;) //设置元素文本内容3.表单的值val()(相当于原生value)遍历元素jQuery隐式迭代是对同一类元素作了同样的操作，如果想要给同一类做不同的操作，就要用到遍历 语法1$(&quot;div&quot;).each(function(index,domEle){xxx;})1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 2.里面大的回调函数有两个参数：index是每个元素的索引号；domEle是每隔DOM元素对象不是jQuery对象 3.所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle) 语法2$.each(object,function(index,element){xxx;})1.$.each()方法可用于遍历任何对象，主要是数据处理。比如数组对象 2.里面的函数有2个参数：index是每个元素的索引号；element遍历内容 添加元素1.内部添加element.append(&quot;内容&quot;)把内容放入匹配元素内部最后面，类似原生appendChild element.prapend(&quot;内容&quot;)2.外部添加element.after(&quot;内容&quot;) //把内容放入目标元素后面element.before(&quot;内容&quot;) //把内容放入目标元素前面内部添加元素，生成之后，他们是父子关系 外部添加元素，生成之后，他们是兄弟关系 删除元素element.remove() //删除匹配的元素（本身）element.empty() //删除匹配的元素集合中的所有子节点element.html(&quot;&quot;) //清空匹配的元素内容事件处理事件处理on()绑定事件on()方法在匹配元素上绑定一个或多个事件处理函数 element.on(events,[selector],fn)1.events:一个或多个空格分隔的事件类型，如click或者keydown 2.selector：元素的子元素选择器 3.fn：回调函数，即绑定在元素身上的侦听函数 on()方法的优势1.可以绑定多个事件 多个事件处理程序$(&quot;div&quot;).on({ mouseover:function(){}, mouseout:function(){}, click:function(){} });如果事件处理程序相同 $(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function(){ $(this).toggleClass(&quot;current&quot;); });2.可以事件委派操作，事件委派的定义就是，把原来加给子元素事件绑定在父元素身上，就是把事件委派给父元素$(&#39;ul&#39;).on(&#39;click&#39;,&#39;li&#39;,function(){ alert(&#39;hello world!&#39;); });在此之前有bind(),live() delegate()等方法来处理事件绑定或者事件委派，最新版用on代替他们 3.动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件事件处理off()解绑事件off()方法可以移除通过on()方法添加的事件处理程序 $(&quot;p&quot;).off() //解绑p元素所有事件处理程序 $(&quot;p&quot;).off(&quot;click&quot;) //解绑p元素上面的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;); //解绑事件委托如果事件只想触发一次，可以使用one()来绑定事件 自动触发事件trigger()有些时间希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮的点击事件，不必鼠标点击触发 element.click() //第一种简写方式element.trigger(&quot;type&quot;) //第二种自动触发模式$(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;hi~&quot;); }); $(&quot;p&quot;).trigger(&quot;click&quot;); //此时自动触发点击事件，不需要鼠标点击jQuery事件对象事件被触发，就会有事件对象的产生。 element.on(events,[selector],function(event){})阻止默认行为：event.preventDefault() 或者 return false 阻止冒泡：event.stopPropagation jQuery对象拷贝如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法 $.extend([deep],target,object,[objectN])1.deep:如果设为true为深拷贝，默认false为浅拷贝 2.target：要拷贝的目标对象 3.object1：代拷贝到第一个对象的对象 4.objectN：待拷贝到第N个对象的对象 5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象 6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改的目标对象不会影响被拷贝的对象。 jQuery多库共存jQuery使用$作为标识符随着jQuery的流行，其他js库也用这$作为标识符，这样一来就会引起冲突。需要一个解决方案，让jQuery和其他的js和其他的js库不存在冲突，可以同时存在。这就叫做多库共存。 解决方案1.把里面的$符号统一改为jQuery。比如jQuery(“div”) 2.jQuery变量规定新的名称：$.noConflict() 如： var xxx =$.noConflict(); jQuery插件1.jQuery插件库 http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ 使用步骤1.引入相关文件（jQuery文件和插件文件） 2.复制相关的html，css，js（调用插件） 常用插件1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度，它也能帮助减轻服务器负载) 当我们页面滑动得到可视区域，在显示图片，使用插件库的EasyLazyload，注意此时引入的文件和js调用必须写在DOM元素（图片）最后面 3.全屏滚动（fullpage.js) GitHub：https://github.com/alvarotrigo/fullPage.js 中文翻译网：http://www.dowebok.com/demo/2014/77/ bootstrap中文文档https://v3.bootcss.com 能够操作jQuery元素尺寸、位置jQuery尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值 只算width/height innerWidth() /innerHeight() 取得匹配元素宽度和高度值 包含padding outerWidth()/outerheight() 取得匹配元素的宽度和高度值 包含padding、border outerWidth(ture)/outerHeight(ture) 取得匹配元素宽度和高度值 包含padding、border、margin 以上参数为空，则是获取相应值，返回的是 数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 jQuery位置位置主要有三个：offset()、position()、scrollTop()/scrollLeft() 1.offset()设置或获取元素偏移offset()方法设置或返回被选中元素相当于文档的偏移坐标，跟父级没有关系 该方法有2个属性left、top、offset()、top 用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({top:10,left:30}); 2.position() 获取元素偏移position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。这个方法只能获取不能设置偏移。 3.scrollTop() /scrollLeft()设置或获取元素被卷去的头不和左侧srcollTop()方法设置或返回被选元素被卷去的头部","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2020-04-09T16:00:00.000Z","updated":"2020-07-30T04:04:59.820Z","comments":true,"path":"2020/04/10/原型和原型链/","link":"","permalink":"https://www.iamys.club/2020/04/10/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"构造函数创建对象function Person(){ } var person = new Person(); person.name = &#39;Kevin&#39;; console.log(person.name);//KevinPerson是个构造函数，使用new创建了一个实例对象person. prototype每个函数都有一个prototype属性,也是函数才有的属性 function Person(){ } Person.prototype.name=&#39;Kevin&#39; var person1=new Person() var person2=new Person() console.log(person1.name)//Kevin console.log(person2.name)//Kevin函数的prototype属性指向的是一个对象，这个对象时调用该构造函数而创建的实例的原型，也就是例子中的person1和person2的原型。 __proto__这是每一个JavaScript对象（除了null）都具有的一个属性，它指向该对象的原型。 function Person(){ } var person=new Person() console.log(person.__proto__===Person.prototype) constructor这是原型指向构造函数的属性，每一个原型都有一个constructor属性指向关联的构造函数。 function Person(){ } console.log(Person===Person.prototype.constructor)//true 总结function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true实例和原型当读取实例对象中的属性，读取不到时就回去查找实例对象的原型中的属性，如果还是没找到就会去原型的原型中找，直到找到顶层为止 function Person() { } Person.prototype.name = &#39;Kevin&#39;; var person = new Person(); person.name = &#39;Daisy&#39;; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin原型的原型原型也是一个对象，既然是对象就用原始的方法创建它 var obj = new Object(); obj.name = &#39;Kevin&#39; console.log(obj.name) // Kevin其实原型对象就是由Object构造函数生成的 原型链Object.prototype的原型是null，也就是没有原型，所以查找到Object.prototype就可以停止查找了 console.log(Object.prototype.__proto__ === null) // true 图中由相互关联的原型组成的链状结构就是原型链，也就是__proto__蓝色的一条线 补充最后，补充三点大家可能不会注意的地方： constructorfunction Person() { } var person = new Person(); console.log(person.constructor === Person); // true当获取 person.constructor 时，其实 person中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： person.constructor === Person.prototype.constructor__proto__绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用 obj.__proto__ 时，可以理解成返回了Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]},{"title":"this全面解析","slug":"this全面解析","date":"2020-04-08T16:00:00.000Z","updated":"2020-07-31T15:11:42.641Z","comments":true,"path":"2020/04/09/this全面解析/","link":"","permalink":"https://www.iamys.club/2020/04/09/this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"this 关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在 所有函数的作用域中。但是即使是非常有经验的 JavaScript 开发者也很难说清它到底指向 什么。 实际上，JavaScript 中 this 的机制并没有那么先进，但是开发者往往会把理解过程复杂化， 毫无疑问，在缺乏清晰认识的情况下，this 对你来说完全就是一种魔法 为什么要用this使用this可以在不同的上下文对象中重复使用函数，不用针对每个对象编写不同版本的函数； 如果不使用this那就得给函数显示的传入一个上下文对象，随着你使用的模式越来越复杂，显示传递上下文对象会让代码越来越混乱； 而this提供了一种更优雅的方式来隐式传递一个对象引用，可以是API设计得更加简洁并且易于复用。 解开this的误解 this并不指向函数自身 this也不一定总指向函数的作用域 this到底是什么this实际上是在函数调用时发生绑定的，它指向什么完全取决于函数在哪里被调用。 调用位置有时候会被隐藏，可以分析调用栈也就是为了到达当前执行位置所调用的所有函数，要注意的是调用位置就在正在执行的函数的前一个调用中。 可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 this的绑定规则以及优先级默认绑定最常用的函数调用类型：独立函数调用（函数的调用在全局不加任何修饰）。可以把这条规则看作是无法应用 其他规则时的默认规则，this指向全局对象window，但是如果时严格模式下this的绑定是undefined。 var bar = foo()隐式绑定需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，绑定在那个上下文对象。 obj1.foo()当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的 注意：对象属性引用链中只有最顶层或者说最后一层会影响调用位置obj1.obj2.foo()时this指向obj2 隐式丢失 上下文对象引用之后赋值在全局调用 把函数作为参数进行值传递在全局调用 把函数传入语言内置函数中调用 显示绑定由call、apply、bind调用，绑定到指定对象上 var bar = foo.call(obj2)new绑定是否由new调用，绑定到新创建的对象上 var bar = new foo()new调用函数自动执行的操作 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 优先级new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定 绑定例外 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则 ​ 安全的做法：在忽略 this 绑定时总是传入一个 DMZ 对象 var ø = Object.create( null ); foo.apply( ø, [2, 3] ); 创建一个函数的“间接引用（间接引用最容易在赋值时发生）”，在这 种情况下，调用这个函数会应用默认绑定规则。 this词法ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]},{"title":"JavaScript进阶","slug":"js高级","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-10T06:50:46.219Z","comments":true,"path":"2020/04/06/js高级/","link":"","permalink":"https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"1.面向对象和类的继承什么是面向对象面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。 面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。 面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适合多人合作的大型软件项目 面向对象的特性：封装性、继承性、多态性 面向对象的思维特点：1.抽取（抽象）对象公用的属性和行为组织（封装）成一个类（模板） 2.对类进行实例化，获取类的对象 面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象，使用对象，指挥对象做事情 类和对象的关系对象对象是一个具体的事务，在javascript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。 对象是由属性和方法组成的 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 类class在ES6中添加了类的概念，可以使用class关键字声明一个类，之后这个类来实例化对象。 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化的一个具体的对象 使用class创建自定义类语法：class name{ //class body }创建实例：var xx = new name;注意：类必须使用new实例化对象 类的constructor构造函数constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor() 类添加方法语法： class Person{ constructor(name,age){ this.name=name; this.age=age; } say(){ console.log(this.name+&#39;你好&#39;)； } }什么是继承子类可以继承父类的一些属性和方法。 语法：class Father{ } class Son extends Father{ }super关键字super关键字用于访问和调用父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数 调用构造函数语法：class Person { //父类 constructor(surname){ this.surname = surname; } } class Student extends Person { //子类继承父类 constructor(surname,firstname){ super(surname); //调用父类的constructor(surname) this.firstname = firstname; //定义子类独有的属性 } }注意：子类在构造函数中使用super，必须放在this前面（必须先调用父类的构造方法在使用子类构造方法） 调用普通函数语法：class Father{ say(){ return &#39;我是爸爸&#39;; } } class Son extends Father { say(){ //super.say() super调用父类方法 return super.say()+&#39;的儿子&#39;; } } var damo = new Son(); console.log(damo.say());注意：在继承中的属性和方法查找原则是就近原则，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的，如果没有就在父类中找有没有这个方法，如果有就执行父类的这个方法。 四个注意点1.在ES6中类没有变量提升，所以先定义类，再实例化对象 2.类里面的共用属性和方法一定要加this使用 3.类里面的this指向问题 4.constructor里面的 this指向实例化对象，方法里面的this指向这个方法的调用者 2.构造函数和原型使用构造函数创建对象概述在ES6之前没有引入类的概念，所以对象不是基于类创建的，而是 一种称为构造函数的特殊函数来定义对象和他们的特征 创建对象可以通过以下三种方式： 1，对象字面量 2，new Object() 3,自定义构造函数 构造函数构造函数是一种特殊的函数 ，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用，我们可以把对象中的共有属性和方法抽取出来，然后封装到这个函数里面 在js中使用构造函数要注意以下两点： 1.构造函数用于创建一类对象，其首字母要大写 2.构造函数要和new一起使用才有意义 new在执行时会做四件事情：1.在内存中创建一个新的空对象 2.让this指向这个新的对象 3.执行构造函数的代码，给这个新对象添加属性和方法 4.返回这个新对象（所以构造函数里面不需要return） 成员分类JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方法添加的成员，就分别称为静态成员和实例成员 静态成员：在构造函数本身上添加的成员为静态成员，只能由构造函数 本身来访问 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 构造函数的问题构造函数的方法虽然很好用，但是存在浪费内存的问题，因为如果构造函数里面添加了方法这种复杂数据类型，我们每实例化一个对象就会开辟新的空间存放这种复杂数据类型，这样是很没有必要的，所以就有了构造函数的原型prototype 原型的作用构造函数原型prototype构造函数通过分配的函数是所有对象所共享的。 JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。 function Star(uname, age) { this.uname = uname; this.age = age; // this.sing = function() { // console.log(&#39;我会唱歌&#39;); // } } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(ldh.sing === zxy.sing); ldh.sing(); zxy.sing(); // 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。 问答 1.原型是什么？ 一个对象，我们也称为原型对象 2.原型的作用是什么？ 共享方法 对象原型 proto对象都有一个属性proto指向构造函数的原型对象prototype，之所以我们对象可以使用构造函数prototype原型对象的方法和属性，就是因为对象有proto原型存在。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 对象原型proto和原型对象prototype是等价的 proto对象原型大的意义在于为对象的查找机制提供了一个方向，或者说是一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype constructor构造函数对象原型__proto __和构造函数原型对象prototype里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() { console.log(&#39;我会唱歌&#39;); }, movie: function() { console.log(&#39;我会演电影&#39;); } } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor);constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数 构造函数、实例、原型对象三者之间的关系原型链 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 扩展内置对象可以通过原型对象，对原来内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。 注意：数组和字符内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum; }; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum());访问对象成员的规则JavaScript成员查找机制 1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 2.如果没有就查找它的原型（也就是proto指向的prototype原型对象） 3.如果还没有就查找原型对象的原型（Object的原型对象） 4.依次类推一直到找到Object为止（null） 5.proto对象原型的意义在于为对象成员查找机制提供了一个方向，或者说是一条线路 继承ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()调用这个函数，并且修改函数运行时的this指向 fun.call(thisArg,arg1,arg2,……)thisArg：当前调用函数this的指向函数 arg1，arg2：传递的其他参数 function fn(x, y) { console.log(&#39;我想喝手磨咖啡&#39;); console.log(this); console.log(x + y); } var o = { name: &#39;andy&#39; }; // 1. call() 可以调用函数 fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age);// 借用父构造函数继承属性 this.score = score; } Son.prototype = new Father(); //借用原型对象继承方法 // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log(&#39;孩子要考试&#39;); } var son = new Son(&#39;刘德华&#39;, 18, 100); console.log(son);ES5新增的一些方法数组方法 迭代（遍历）方法：forEach()、map()、filter()、some()、every() array.forEach(function(currenValue,index,arr))currentValue:相当于当前项的值 index：数组当前项的索引 arr：数组对象本身 // forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) { console.log(&#39;每个数组元素&#39; + value); console.log(&#39;每个数组元素的索引号&#39; + index); console.log(&#39;数组本身&#39; + array); sum += value; }) console.log(sum);array.filter(function(currenValue,index,arr))filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组，它直接返回一个新的数组。 // filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) { // return value &gt;= 20; return value % 2 === 0; }); console.log(newArr);array.some(function(currenValue,index,arr))some()方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件大的元素，它返回值是布尔值，如果查找这个元素就返回true，找不到就返回false var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]; // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) { if (value == &#39;green&#39;) { console.log(&#39;找到了该元素&#39;); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 } console.log(11); });字符串方法 trim()方法会从一个字符串的两端删除空白字符 str.trim()trim()方法并不影响原字符串本身，它返回的是一个新的字符串。 对象方法 Object.keys()用于获取对象自身的所有属性 Object.keys(obj)效果类似for…in 返回一个由属性名组成的数组 // 用于获取对象自身所有的属性 var obj = { id: 1, pname: &#39;小米&#39;, price: 1999, num: 2000 }; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) { console.log(value); })Object.defineProperty()定义新属性或修改原有的属性 Object.defineProperty(obj,prop,descriptor)Object.defineProperty()第三个参数descriptor说明：以对象形式{}书写 value：设置属性的值 默认为undefined writable：值是否可以重写。true|false 默认为false enumerable：目标属性是否可以被枚举。true|false 默认false configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认是false 3.函数进阶说出函数的多种定义和调用方式函数的定义方式1.函数声明方式function关键字（命名函数） function fn(){};2.函数表达式（匿名函数) var fun = function(){};3.new Function() var fn = new Function(&#39;参数1&#39;，&#39;参数2&#39;……,&#39;函数体&#39;) Function里面的参数必须是字符串格式 这种方式执行效率低，也不方便使用，因此使用较少 所有的函数都是Function的实例（对象） 函数也属于对象 函数的调用方式1.普通函数 function fn() { console.log(&#39;这是一个普通函数&#39;); } fn(); fn.call();2.对象的方法 var o = { sayHi: function() { console.log(&#39;这是对象的方法&#39;); } } o.sayHi();3.构造函数 function Star() { console.log(&#39;这是一个大写的构造函数&#39;); } new Star();4.绑定事件函数 var btn = document.querySelector(&#39;button&#39;); btn.onclick = function() { console.log(&#39;这是一个绑定事件函数&#39;); }5.定时器函数 setTimeout(function() { console.log(&#39;这是定时器函数&#39;) }, 1000);6.立即执行函数 (function() { console.log(&#39;这是一个立即执行函数&#39;); })()说出和改变函数内部this的指向函数内的this指向this的指向是当我们调用函数时确定的，调用的方式不同决定了this的指向不同，一般指向调用者。 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象，原型对象里的方法也指向实例对象 对象的方法对象 该方法所属的对象 事件绑定方法 绑定的事件对象 定时器函数 window 立即执行函数 window 改变函数内部的this指向JavaScript提供了函数和方法帮助我们改变函数内部this的指向，常用的有bind() call() apply() call() var o = { name: &#39;andy&#39; } function fn(a, b) { console.log(this); console.log(a + b); } fn.call(o, 1, 23) //可以调用函数，可以改变this指向，可以传递普通参数 //主要应用于继承 function Father(uname, age, sex) { this.uname = uname; this.age = age; this.sex = sex; } function Son(uname, age, sex) { Father.call(this, uname, age, sex); } var son = new Son(&#39;刘德华&#39;, 12, &#39;男&#39;) console.log(son);apply() var o = { uname: &#39;andy &#39; } function fn(arr) { console.log(this); console.log(arr); } fn.apply(o, [&#39;hello&#39;]);//可以调用函数，可以改变this指向，但是第二个参数必须是数组 //apply主要应用于用数学内置函数求数组最大最小值 var arr = [12, 33, 77, 1, 0] var max = Math.max.apply(Math, arr) var min = Math.min.apply(Math, arr) console.log(max, min);bind() var o = { name: &#39;andy&#39; }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); //不会调用函数 ，可以改变this的指向，返回的时改变后的新函数 f();// bind()的主要应用：函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 var btn = document.querySelectorAll(&#39;button&#39;); for (var i = 0; i &lt; btn.length; i++) { btn[i].onclick = function() { this.disabled = true; setTimeout(function() { this.disabled = false; }.bind(this), 2000) } }说出严格模式的特点严格模式（strict modes）JavaScript变体的一种方式，即在严格的条件下运行js代码，它对正常的js语义做了一些更改： 消除了JavaScript语法的一些不合理，不谨慎之处，减少了一些怪异行为 消除了代码运行的不安全之处，保证了代码运行的安全 提高编译器效率，增加运行速度 禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来的JavaScript做好了铺垫。 开启严格模式严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 为脚本开启严格模式&lt;scprit&gt; &#39;use strict&#39;; console,log(&quot;这是严格模式&quot;); &lt;/scprit&gt; //不常用，影响文件合成为函数开启严格模式 &lt;script&gt; (function() { &#39;use strict&#39;; })(); &lt;/script&gt;严格模式中的变化变量的变化 在正常模式下如果一个变量未声明就赋值默认是全局变量，在严格模式下禁止这样使用变量必须先用var声明再使用。 严禁删除已声明的变量 严格模式下this的指向问题 以前全局作用域函数this指向window，严格模式下全局作用域的函数this指向undefined 以前构造函数不加new调用当成普通函数调用且this指向window，严格模式下会报错 new实例化的构造函数还是指向创建的对象实例 定时器this还是指向window 事件、对象还是指向调用者 函数的变化 函数不能有重名的参数 函数必须声明在顶层，不能声明在for if 之类的里面 把函数作为参数和返回值传递高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出 function fn(a, b, callback) { console.log(a + b); callback &amp;&amp; callback(); } fn(1, 2, function() { console.log(&#39;我是最后调用的&#39;); });function fn(){ return function() {}; } fn();说出闭包的的作用什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。简单说就是一个作用域可以访问另一个函数内部的局部变量。 闭包的作用闭包的主要作用：延伸了变量的作用范围 闭包案例循环注册点击事件 var lis = document.querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i); }循环中的setTimeout() //3秒钟后打印所有的li var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i) }计算打车价格 说出递归的两个条件什么是递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，简单的说就是一个函数自己调用自己就是递归函数。递归函数的作用和循环时一样的。由于递归函数很容易发生“栈溢出”错误（stack overflow），所以必须加退出条件return。 递归的两个条件：一自身调用，二退出条件 //利用递归求1-n的阶乘 function fn(n) { if (n == 1) { return 1; } return n * fn(n - 1); } console.log(fn(4));//利用递归求斐波拉及数 function fun(i) { if (i == 1 || i == 2) { return 1; } return fun(i - 1) + fun(i - 2); } console.log(fun(4));说出深拷贝和浅拷贝的区别1.浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用 Object.assign(target,…sources) es6新增的方法可以实现浅拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; var o = {}; for (var k in obj) { //k是属性名，obg[k]是属性值 o[k] = obj[k]; } console.log(o); o.msg.age = 20;//这种复杂数据类型拷贝的是地址额，当一个改变原来的也会改变 console.log(obj); Object.assign(o, obj);2.深拷贝拷贝多层，每一次的数据都会拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var o = {}; //封装函数 function deepCopy(newobj, oldobj) { for (k in oldobj) { var item = oldobj[k]; //判断数据类型 if (item instanceof Array) { newobj[k] = []; deepCopy(newobj[k], item); } else if (item instanceof Object) { newobj[k] = {}; deepCopy(newobj, item); } else { newobj[k] = item; } } } deepCopy(o, obj); o.msg.age = 90;//修改拷贝过的对象里的方法，原对象不会有影响 console.log(o); console.log(obj);4.正则表达式说出正则表达式的作用什么是正则表达式正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象 正则表达式的作用正则表达式通常用检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名，表单只能输入英文字母，数字或下划线，昵称可以输入中文（匹配）；此外，正则表达式还常用于过滤页面中内容的一些敏感词（替换）；或从字符串中提取我们想要的特定部分（提取）。 正则表达式的特点 灵活性、逻辑性和功能性非常强 可以迅速的用极为简单的方法达对字符串的复杂控制 对于刚接触的人可能比较晦涩难懂 实际开发一般都是直接复制写好的正则表达式，但是要求我们能看懂并且根据需求修改 写出简单的正则表达式创建正则表达式1.通过RegExp对象的构造寒素创建 var 变量名 = new RegExp(/表达式/)2.通过字面量创建 var 变量名 = /表达式/;测试正则表达式texttext()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数式测试字符串 regexobj.text(str) regexobj是写的正则表达式 str是我们要测试的文本 作用是检测str文本是否符合我们写的正则表达式 正则表达式的组成一个正则表达式可以由简答的字符组成，比如/abc/，也可以是简单和特殊字符的组合，比如/ab*c/，其中特殊字符也被称为原字符，在正则表达式中具有特殊意义的符号，如^,$,+等。 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要由两个字符， 边界符 说明 ^ 表示匹配行首大的文本（从谁开始） $ 表示匹配行尾的文本（以谁结束） 字符类字符类有一系列的字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号中就可以了。[a-z]表示从a到z。方括号里面可以使用字符组合如：[a-zA-Z0-9]；方括号中的^是取反符[^]。 量词符量词符用来设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ？ 重复一次或零次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 括号总结 大括号 量词符 里面重复的次数 中括号 字符集合 匹配方括号中的任意字符 小括号 表示优先级 预定义类预定义类表示的是常见模式的简写方式 预定类 说明 \\d 匹配0-9之间的任意一个数字，相当于[0-9] \\D 匹配所有0-9之外的字符，相当于 [ ^ 0-9 ] \\w 匹配任意字母数字下划线，相当于[a-zA-Z0-9_] \\W 匹配所有字母数字下划线以外的字符，相当于[ ^a-zA-Z0-9_] \\s 匹配空格 换行符制表符空格符等 \\S 匹配非空格字符 使用正则表达式对表单进行验证使用正则表达式替换内容raplace()raplace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式 stringObject.replace(regexp/substr,replacement) 第一个参数：被替换的字符串或者正则表达式 第二个参数：替换为大的字符串 返回值十一和替换完毕的新字符串 正则表达式参数/表达式/[switch]switch（也称为修饰符）按照什么样的模式匹配，有三种值 g：全局匹配 i：忽略大小写 gi：全局匹配+忽略大小写 5.ES6ES6概述什么是ES6ES的全ECMAScript，它是由ECMA国际标准化组织制度的一项脚本语言的标准化规范，2015年的版本叫做ES2015，2016年的版本叫做ES2016……所以ES6实际上是泛指ES2015及后续的版本。 为什么要使用ES6每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript本身有一些让人不满意的地方。比如变量的提升特性增加了程序运行的不可预测性，语法过于松散，实现相同的功能不同的人可能写出不同的代码…… 变量letES6中新增的声明变量的关键字 let的特点特点1：let声明的变量只在处于块级有效（大括号中定义的，只在大括号中有效） if(true){ let a =10; } console.log(a); //a is not defined注意：let声明的变量只在块级作用域下有效，但是var声明的变量不具有块级作用域的特性。 特点2：不存在变量提升（不能先用再声明） console.log(a); //a is not defined let a = 10 ;特点3：暂时性死区 var num = 10 if (true) { console.log(num); //因为在块级作用域有let关键字，所以var定义的全局不起作用，let在后面定义前面打印就会出错。 let num = 20; }let的经典面试题 var arr = []; for (var i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //2 arr[1](); //2 //关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值 let arr = []; for (let i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //0 arr[1](); //1 //关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上 一级（循环每次产生的块级作用域）作用域下的i值常量const作用：声明常量，常量就是值（内存地址）不会发生变化的量 特点1：具有块级作用域 if(true) { const a=10; } console.log(a); //a is not defined特点2：声明常量必须赋值 conts PI; //错误，PI没有赋初值特点3：常量赋值后，值不能修改 const PI = 3.14; PI = 100; //错误：Assignment to constant variable. const ary = [100, 200]; ary[0] = &#39;a&#39;; ary[1] = &#39;b&#39;; console.log(ary); //[&#39;a&#39; ,&#39;b&#39;] ary = [&#39;a&#39;, &#39;b&#39;]; // 错误 Assignment to constant variable.let、const、var的区别 var let const 函数级作用域 块级作用域 块级作用域 变量提升 不存在变量提升 不存在变量提升 值可更改 值可更改 值不可更改 解构赋值ES6中允许从数组中提取值，按照对应的位置对变量赋值，对象也可以实现解构。 数据解构数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋给变量。 let [a, b, c] = [1, 2, 3]; console.log(a); //1 console.log(b); //2 console.log(c); //3当数组中的值和变量不是一一对应关系，变量的值就是undefined let [foot] = []; let [foo, bar] = [11]; console.log(foot, foo, bar); //undefined 11 undefined对象结构let person = { name: &#39;张三&#39;, age: 20 }; let {name,age} = person console.log(name); //张三 console.log(age); //20 let {name: myName} = person; //也可以使用别名获取 console.log(myName);箭头函数ES中新增的定义函数的方式 () =&gt; {} //如下 const fn = () =&gt; { console.log(123); } fn(); //如果函数体中只有一句代码并且代码的执行结果就是函数的返回值，函数体大括号可以省略 const sum = (n1, n2) =&gt; { return n1 + n2; } //可简写为： const sum = (n1, n2) =&gt; n1 + n2; console.log(sum(1, 2)); //如果形参只有一个参数可省略小括号 const fun = (v) =&gt; { alert(v); } //可简写为 const fun = v =&gt; { alert(v) } fun(7);箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 剩余参数剩余函数允许我们将不定数量的参数表示为一个数组 function sum(first, ...args) { console.log(first); //10 console.log(args); //[20,30,40] } sum(10, 20, 30, 40);剩余参数配合解构使用 let ary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; let [s1, ...s2] = ary; console.log(s1); //&#39;a&#39; console.log(s2); //[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]Array的扩展方法扩展运算符（展开语法）1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。 let ary = [1, 2, 3]; console.log(...ary); //1 2 3 注意这里逗号被当成了log的分隔符2.扩展运算符可以应用于合并数组 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; console.log(ary3); //[1,2,3,4,5,6] ary1.push(...ary2); console.log(ary1); //[1,2,3,4,5,6]3.扩展运算符可以将类数组或可遍历的对象转换为真正的数组，以便调用数组的方法 let divs = document.querySelectorAll(&#39;div&#39;); let oDivs = [...divs]; oDivs.push(&#39;abc&#39;) console.log(oDivs); //[div, div, div, div, div, &quot;abc&quot;]构造函数的方法：Array.from()1.将类数组或可遍历的数组转换为真正的数组 let arrLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; let arr = Array.from(arrLike); console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]2.这个方法还可以接受第二个参数，作用类似于数组map方法，用于对每个元素进行处理，将处理后的值放入数组。 let arrLike = { &#39;0&#39;: &#39;2&#39;, &#39;1&#39;: &#39;3&#39;, &#39;2&#39;: &#39;4&#39;, length: 3 }; let arr = Array.from(arrLike, item =&gt; item * 2); console.log(arr); //[4, 6, 8]实例方法:find()用于找出第一个符合条件的数组成员，如果没有找回就返回undefined let ary = [{ id: 2, name: &quot;张三&quot; }, { id: 2, name: &quot;李四&quot; }]; let target = ary.find(item =&gt; item.id == 2); console.log(target); //{id: 2, name: &quot;张三&quot;}实例方法:findIndex()用于找到第一个符合条件的数组成员的位置，如果没有找到返回-1 let ary = [1, 5, 10, 15]; let index = ary.findIndex(value =&gt; value &gt; 9); console.log(index); //2实例方法:includes()表示某个数组是否包含给定值，返回的是布尔值 [1,2,3].includes(2) //trueString的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义 let name = `zhangsan`;模板字符串可以解析变量 let name = `zhangsan`; let sayHello = `hello my name is ${name}`; console.log(sayHello);模板字符串可以换行 let res = { name: &#39;张三&#39;, age: 12 } let html = ` &lt;div&gt; &lt;span&gt;${res.name}&lt;/span&gt; &lt;span&gt;${res.age}&lt;/span&gt; &lt;/div&gt;`; console.log(html);模板字符串可以调用函数 const fn = () =&gt; &#39;我是fn函数&#39; let html = `我是模板字符串 ${fn()}`; console.log(html)实例方法：starsWith()和endsWith() starsWith():表示参数字符串是否在原字符串的头部，返回布尔值 endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值 let str = &#39;Hello ECMAScript 2015&#39;; let r1 = str.startsWith(&#39;Hello&#39;); //true console.log(r1); let r2 = str.endsWith(&#39;2016&#39;); //false console.log(r2)实例方法：repeat()表示将原字符重复n次返回一个新字符串 console.log(&quot;y&quot;.repeat(5)) //yyyyyset数据结构ES6提供了新的数据结构Set，它类似于数组，但成员的值都是唯一的，没有重复的。 Set本身是一个构造函数，用来生成Set数据结构。 const s = new Set();Set 函数可以接受一个数组作为参数，用来初始化。 const set = new Set([1,2,3,4,4]);实例方法 add(Value):添加某个值，返回Set结构本身 delete(value):删除一个值，返回一个布尔值，表示删除是否成功。 has(value):返回一个布尔值，表示该值是否为Set的成员 clear():清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2); //向set结构中添加值 s.delete(2); //删除set结构中的2值 s.has(1) //表示set结构中是否有这个值，返回布尔值 s.clear() //清除s中的所有值遍历Set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 s.forEach(value =&gt; console.log(value))","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.iamys.club/tags/git/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.iamys.club/tags/python%E7%88%AC%E8%99%AB/"},{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"},{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"},{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}